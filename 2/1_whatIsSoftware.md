# 什么是软件
或许, 我也很难给 "什么是软件" 下一个准确而且没有歧义的定义吧.

但是, 在正式开始我们的软件篇之前, 我还是感觉很有必要说明一下什么是 "软件".

软件, 顾名思义, 我们或许在硬件上摸不到也看不到它的存在, 但它又确实自身组成了一个小小的功能核心.

或者, 相对于物理世界, 我们暂且就把它当作 "魔法" 来讲吧.

魔法, 或者说软件, 在我的世界里, 它们有着很多的相似之处. 接下来我将用我的经验来直观且感性的描述什么是软件.


# 一套魔法是一系列运作规则的组成
毫无疑问, 一套魔法的本质是一套预先设计好的运作规则. 至少在我生活的世界里是这样的.

你现在所接触到的软件也不例外. 在这个世界里, 看似庞大且神奇的一切都是由预先设定好的一组动作规律所完成的.

若要描述一组动作规律, 它并不需要像数学公式一样晦涩难懂. 比如, 现在让我们拆开计算器负责加法运算的程序, 你可能会看到这样:

> 1. 获取一个数字, 将它保存在寄存器 A

> 2. 再获取一个数字, 将它保存在寄存器 B

> 3. 执行加法运算, 操作: A和B, 将结果保存到寄存器 C

> 4. 将寄存器C的内容输出到显示屏

唔... 是不是还是挺好懂的? 那么, 让我们现在再进阶一点, 如何让程序来判断一个数字是否是奇数呢?

> 1. 获取一个数字, 将它保存在寄存器 A

> 2. 将寄存器B的内容设置为数字2

> 3. 执行除法运算, 操作: A是被除数, B是除数, 将结果保存在寄存器 C, 将余数保存在寄存器 D

> 4. 如果寄存器D的内容是0, 则跳到7继续执行, 否则继续向下执行

> 5. 输出: 这是奇数

> 6. 在此处中断执行, 停止执行下面的任何内容

> 7. 输出: 这是偶数

没错, 就是这样! 你现在应该对 "软件" 有一个直观的了解了 -- 就算它再复杂, 它也只是简单的一些基本操作的堆叠而已, 仅此而已呀!

一切的一切, 只不过因为我们施放魔法的这一瞬间往往太快了, 我们来不及看清这一切就已经完成. 

换句话说, 当一个软件被执行下去的一瞬间, CPU往往会在短时间内把一切都做好了, 我们看不清这其中发生了什么, 就好像一切都是在同时发生一样.


# 魔法的原理并不能架空
没错, 根据著名的能量守恒定律和物质守恒定律, 就算是我也不能空放魔法, 大家任何人都不例外.

因此, 一个软件要实现某个功能, 它必然要具备最基础的"可行性", 至少理论条件上必须可行.

比如我们不可能凭空写一个软件来检测用户的手机壳颜色~ 这就是所谓的理论条件上不可行. 至于为什么? 当然是因为用户的手机壳颜色它根本不可能影响到CPU的执行呀对吧...

(当然如果哪天谁发明了这种软件, 我会很高兴的, 恭喜这位人士有概率诺贝尔奖金榜题名...)


# 魔法的运作并不万能
是的, 即便是魔法世界, 魔法的运作也并不万能. 要不然, 为什么魔法世界不是永远和平且安全的呢?

嗯, 说点实际且对你有帮助的. 即使软件可以变得极为庞大, 即使我们的处理器和存储器性能可以几何规模的扩大, 在这个世界上, 总是有些问题我们无法单单通过软件解决:

就拿这个举例子吧: 我们很难写一个软件给图片去除马赛克. 当然, 我是说很难, 这样的软件已经存在了, 但依然非常的不完善. 至于原因, 且听我分析:

> 要解释这个问题, 我们可能要扯到信息论的问题. 我会尽可能的用你能理解的最简单的办法来描述它.

> 现在, 吾有一言: "我今天和朋友在9点一起出门吃晚饭". 我会对这句话进行马赛克操作.

> "我???朋友???9点???吃???饭", 假如只是这样, 或许你依然可以通过联想的方式来补充出中间的内容.

> "我???????9点??????????饭", 现在变成了这样, 你会发现内容已经出现了严重的歧义. 它既可以被理解为"我要9点吃饭", 也可以被理解为"我会在9点做饭". 而原本额外附加的信息"和朋友一起"已经消失了.

> "我????????????????????饭", 假若是这样, 它又会被理解成什么样子呢...?

> ....

你看, 因为这样那样的原因, 软件也并不总是万能, 不一定能够解决所有的问题.

因此, 将来的你总是需要按照需求行事, 尝试在众多的"不能"中找到一个"能"的思路.


# 魔法也需要依赖物理的支持
魔法, 需要一种方式来施放. 不管是符文, 还是魔法阵, 还是魔杖...

软件也一样, 它不可能脱离处理器本身自己在运行.

即使软件可以被包装上精美的用户界面, 即使软件可以被无限的简化和易用, 而它最基础的那部分似乎永远都没有变...

那就是处理器的执行单元和运算单元.

无论如何, 软件都要遵循一个基本法, 它无法逾越CPU本身的硬件限制. 比如软件不能自己"思考", 它只能不断地重复着加减乘除以及各种逻辑计算...

再比如你可能早就知道, 软件是有个"位数" 这样的东西, 比如32位程序和64位程序, 他们俩之间还是会有些小区别...

再比如, 一款专为某个CPU指令集设计出的软件, 除非它被"翻译"成另外一个指令集, 否则它将不能在另一个不同指令集的CPU上面执行. 正所谓, 假如语言都不通, 那咱们没得聊了...

...

这就好比我们在打卡牌游戏. 我们不可能逾越卡牌游戏的规则凭空变出一张卡来, 也不能凭空喊出一个招来. 但是我们可以通过精心设计我们的卡组叠放顺序, 选出我们所需要的一个最强大的连招.

而对于软件来说, 这样就是一切了.
