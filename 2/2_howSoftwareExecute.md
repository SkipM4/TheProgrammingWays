# 软件为什么能运行

要解释这么个问题, 我们或许得扯上一点**计算机组成原理**和**编译原理**等等教科书性质的东西.

本文索性不想扯这些专业性太强的东西, 通过一些简单的宏观描述快速让大家补充这些基础知识...


# 计算机的内部结构

拆过电脑的朋友肯定都知道, 计算机有CPU、内存, 还有一大把周边设备, 例如硬盘, 显示器, 键盘鼠标USB....

而对于计算机来说, 哪些是重要的, 哪些是次要的呢?

我们今天不来谈什么冯诺依曼计算机、什么哈佛计算机等计算机架构... 今天我们来研究下拆电脑.

> 拔掉网线, 电脑并不会因此罢工.

> 拔掉鼠标键盘, 电脑还是能工作.

> 拔掉显示器, 电脑还是能工作的样子. 虽然这样我们就不知道电脑的工作状态了... 赶紧插回去, 一切仿佛没有发生.

> 关掉电脑, 把硬盘拔下来. 再次开机, 电脑好像还是显示一个开机动画的样子, 只是没有系统和所有保存的数据了.

**而当你把内存拔掉, 电脑会瞬间死机或者黑屏, 再也开不了机.**

~别和我说拔掉处理器(CPU)和电源线, 这不是废话么...~

可见, 供电, CPU, 内存, 三者显然是计算机比较重要的东西. 抛开供电不谈, 后面两者肯定很重要, 如果少了这两个, 软件就运行不了.

那么我们索性今天来看看这两个东西起什么作用.


# 操作码 (Opcode)

我们之前说过魔法的本质实际上是一组预先设计好的运作规则. 既然如此, 这里一定需要一种东西来简单有效的记录这些动作.

计算机的中央处理器(CPU), 本质实际上在执行着属于它的**代码**. 今天, 我们来了解它更精确的名字 -- **操作码**, 也叫**Opcode**.

不卖关子, 还记得我们之前拆解的那个计算器么? 现在要拆的还是它, 只不过这次我不会再帮你翻译它里面正在执行的代码了. 让我们了解一下什么是操作码:

> 有如下操作码序列:
> 
> 00: 获取一个数字, 保存在指定寄存器中
>
> 01: 执行加法运算, 并将结果保存在指定寄存器中
>
> 02: 输出数字到显示屏
>
>
> 寄存器的对应关系分别为:
>
> 0A: 寄存器A
> 
> 0B: 寄存器B
>
> 0C: 寄存器C

我们继续拆那个计算器, 接下来我们看到了这样的一段代码...

> 00 0A 00 0B 01 0A 0B 0C 02 0C

不要怕, 我来帮你一段段拆解开来:

> 00 0A (00: 获取一个数字, 0A: 将它保存在寄存器A)
> 
> 00 0B (00: 获取一个数字, 0B: 将它保存在寄存器B)
>
> 01 0A 0B 0C (01: 执行加法运算, 0A 0B 0C: 操作: A和B, 将结果保存到寄存器C)
>
> 02 0C (02: 输出数字到显示屏, 0C: 要输出的是寄存器C中的内容)

好像这么一看, 也没那么恐怖吧?


# 指令集

刚刚说的那些操作码, 其实全是我现场乱编出来的. 其实它们除了运行在我的"小47迷你幻想CPU"中, 不能运行在任何地方.

有没有被欺骗的感觉~ 哎呦别打我, 我没有骗你的意思. 我现在给你展示的, 这就是"指令集".

不同型号的CPU, 它的指令都是通用的么? 绝对不是.

你或许听说过什么是x86, 什么是arm, 甚至是最近很火的概念risc-v. 这些都是指令集.

它们语言不通, 所执行的操作码也完全不一样. 不过, 既然大家都是CPU, 包括我的这个迷你幻想CPU, 它们一定程度上的思路肯定是类似的.

说到这里, 你现在也应该明白了为什么电脑(x86)上的软件很多都没办法拿到手机(arm)上运行. 不只是因为操作系统不一样, 更重要的是它们的指令集不一样啊...


顺便一提, 我刚刚所谓"小47迷你幻想CPU", 实则是一个小小的"虚拟机".

而关于这种虚拟机的真正应用, 因为它非常理想, 可以不受硬件限制设计成任何样子, 所以往往应用在"解释型语言上"作为一个中间格式来执行. 至于什么是**解释型语言**, 请看后文. 


哦, 你问我如果指令集不全, 不能实现所有的功能怎么办?

这种情况我们已经帮你考虑好了, 不要担心. 这种情况叫**图灵不完全**, 实际上, 一个图灵不完全的CPU或者编程语言, 它根本就不可能得以出厂 -- 根本就是废物.

你尽管放心这种情况即可. 哦你说我的那个"迷你幻想CPU"? 我当然是没想让它出厂.jpg (遭了, 快逃


# 内存

假如我是中央处理器, 那么正在写这篇文章的我, 是不是需要一张**草稿纸**?

如果我连**草稿纸**都没有, 那我又该往哪写下这些文字呢? 往CPU的壳子上写么?

抱歉, 我如果要在CPU壳子上刻字, 估计刻完之后这CPU本身也报废了...

...

请给我**草稿纸**!!!


没错, 所谓的草稿纸, 就是内存的存在. 它很重要, 软件要运行往往离不开它.

没有草稿纸的心算, 一点也不好玩. 你的CPU就只有一只手数的过来的几个小小寄存器, 就算全部用完又能如何? 换句话说, 一只手只有5个指头, 全部用上又能算出些啥玩意?

我不是在鄙视CPU本身, 而是CPU需要一个更好的帮手来发挥它的全部潜能.


此外要说的是, 内存 **不等于** 你的硬盘等存储器设备.

仔细观察内存条, 你会发现内存条的线路密密麻麻, 其金手指数量恐怖, 可以说是你的电脑主板上除CPU外针脚最多的一个板卡.

这是因为, 为了性能, 内存和CPU之间直接相连, 几乎不通过其他任何桥接和转换电路. 而密密麻麻的线路带来了超大的并行带宽. 如何理解? **路宽, 路多, 且不设收费站和检查点. 这样, 能同时走的车就几何级的增多**.

它一开始就不是为了长期存储一个东西而设计的, 就是要灵活, 要快, 要配得上CPU的执行速度.

这和硬盘什么的完全就是两个东西.

另外, 内存里面的数据可能不像硬盘那样规整. 内存可能会杂乱无章, 就像你的草稿纸, 你只需要随便记一记, 写一写, 自己临时能看得懂和用得上就行. 最多划分个区域, 什么地方写什么不同的待办事项.

这也是为什么内存效率要更高一点的原因之一.


# 操作系统

操作系统本身也是一个软件. 听到这句话, 你应该能反应过来, 既然是软件, 你是可以给换掉的, **甚至是直接不要**.

没错, 没有操作系统的计算机, 叫裸机. 我们通常会在一些系统底层开发和嵌入式开发上这样做, 尤其是一些单片机, 我们会为了性能极限, 直接针对硬件编写代码, 不运行任何操作系统来完成需求.

这种操作有个看似异端的术语: **裸跑**, **裸奔**.


好了, 我们今天先不谈怎么裸跑东西. 后面的硬件篇和嵌入式相关内容, 我会讲的.

现在重点还是有必要说明操作系统在软件执行中的作用.


首先, 不是有着华丽丽的交互界面(GUI)的东西就叫操作系统. 大可不必这么麻烦, 虽然这些东西是操作系统的一个组成部分, 但是今天暂且放到一边去.

操作系统本身是一个很大的管理和框架性质的软件, 它除了可有可无的漂亮界面, 还有**进程调度**, **进程管理**, **设备管理**, **系统调用**等等复杂的功能.


> **进程调度**, 通俗的说, 就是我来帮你掌管CPU的执行. 
>
> 假如我现在要同时做3件事情, 分别是**炒菜**, **洗碗**, **刷盘子**. 
>
> 我可以在炒菜炒到一半的时候找个机会去洗碗; 也可以选择三件事顺着来, 按照菜谱炒一步菜, 再去洗一个碗, 再去刷一个盘子, 这样循环一直到完成; 也可以每件事情做10秒就去做另一件事情, 这样循环...
>
> 负责管理这一切的就是操作系统的任务调度算法. 没错, 看上去电脑里同时运行了这么多程序, 其实这一切都是操作系统的功劳而已.


> **进程管理**, 通俗的说, 就是维护一个软件的开始和结束.
>
> 你有没有想过, 当你双击了一个软件之后, 电脑里发生了什么?
>
> 操作系统的进程管理模块负责将软件的数据从**硬盘**上读出来, 之后按照一定的格式和约定, 将数据加载到**内存**当中去.
>
> 之所以要加载到**内存**, 之前说过了, 内存和CPU直接连接, 不仅读写效率极高, 也方便直接访问和运行.
>
> 之后初始化一系列运行所需要的东西... 并给这个程序接入**调度器**, 在适当的时候分配CPU让其执行.
>
> 所以你感觉软件双击就运行了, 而实际上这还是操作系统的功劳.


> **系统调用**, 也很好理解.
>
> 形象地说, 假如我要烤牛排, 结果供应商却给了我一头活牛. 这河里么? 这不河里.
>
> 我当然是想要处理好的牛排肉片. 这时候, 就是**系统调用**该发挥作用的地方了.
>
> 操作系统其实还为下面运行着的应用软件提供了众多的**系统调用**接口. 每个**系统调用**都是一些不同的功能, 有些是负责文件, 有些是负责设备, 有些是负责控制操作系统本身...
>
> 下面的软件只要拿来主义, 直接用这些功能就好了, 剩下的都交给操作系统来完成. 何乐而不为呢?


# 题外话: 解释语言和编译语言

按照软件的执行过程, 我们也可以将软件分为**解释语言**和**编译语言**两种. 当然, 也有它们两者的混合体.

宏观上的解释语言往往只需要将**源代码**送进**解释器**即可执行, 没有显著的编译过程. 这就好比别人已经替你发明好了炒菜机器人, 而你只需要将清晰易读的菜谱送进这个炒菜机器人, 就可以得到你想要吃的菜.

对于这个炒菜机器人本身是怎么被制造出来的, 你或许并不关注, 或者不需要特别关注其本身.

而**编译语言**拥有显著的将**源代码**编译成**目标代码**的过程. 用户拿到的软件本身往往不再是源码本身, 而是一个直接由**操作码**构成的二进制格式的可执行文件.

这就好比你去餐厅吃饭, 点餐后, 老板交给你的菜品已经是成品, 其如何制作的过程已被完全省略. 而菜谱和原材料只需要老板和厨师等这些餐厅的后台人员掌握即可, 与成品之间没有必然的绑定关系.

那么, 到这里你应该也发现了**解释型语言**和**编译型语言**的一些特性:

> 解释型语言, 每次要用都要附带一个庞大的解释器, 也就是那个炒菜机器人 -- 这对于资源占用来说不是个优势. 而编译型语言则不需要这么多此一举.

> 解释型语言自带的解释器, 那个炒菜机器人, 可能会功能很强大. 这能免去你的很多苦恼. 而编译型语言(尤其是像C语言这样更加底层的语言)可能要你自己去颠勺, 翻炒, 控制文武火... 换句话说就是自己去管理内存, 管理操作系统的调用, 管理句柄...

> 解释型语言因为其更加易用性, 门槛更低. 而门槛低就代表着用的人多, 造轮子的人也多. 能够站在巨人的肩膀上, 对于入门者和快速开发来说往往是不错的选择. 而编译型语言因为其优秀的性能和更小的体积, 以及对火力更加精准的把控, 更适合一些高阶层次的优化, 以及底层结构, 乃至操作系统本身的开发.

我本人往往更推荐入门玩家先从解释型语言入手, 例如**Python** / **PHP**等. 而等我们已经明确了程序设计的一些基本思路之后, 再来入手更高级的领域也没有问题.

前期开挂打游戏来练好心态和手感, 后面再来练枪法, 有问题么? 我不觉得这样有什么问题, 当然不要在多人联机游戏里破坏别人的游戏体验就好了.

*"前面的道路, 以后再来探索吧~"*
